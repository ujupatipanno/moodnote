# 화면을 끝까지 미는 로직 비교 분석

## 목표
스크롤바를 물리적으로 맨 아래까지 내려서, 문서 끝이 화면 하단에 딱 붙도록 만들기

---

## 방법 1: 일반 DOM 요소 접근

### 원리
에디터의 스크롤 컨테이너 DOM 요소를 직접 찾아서 scrollTop을 최댓값으로 설정합니다.

### 로직 흐름
1. view.contentEl에서 시작
2. 스크롤 가능한 요소 탐색 (보통 .cm-scroller 클래스)
3. scrollTop = scrollHeight - clientHeight로 설정

### 장점
- 브라우저 표준 방식이라 이해하기 쉬움
- 어떤 환경에서든 작동 가능
- 추가 라이브러리 불필요

### 단점
- 정확한 클래스명이나 구조를 알아야 함
- Obsidian 버전 업데이트 시 구조 변경 가능
- 여러 스크롤 컨테이너가 있으면 어느 것을 선택할지 애매

### 안정성: ★★★☆☆
DOM 구조가 바뀌면 깨질 수 있음

### 간결성: ★★★☆☆
요소 탐색 로직이 필요

---

## 방법 2: CodeMirror 6 API 사용 (editor.cm.scrollDOM)

### 원리
CodeMirror 6 인스턴스의 scrollDOM 속성을 통해 공식 스크롤 컨테이너에 접근합니다.

### 로직 흐름
1. editor.cm으로 CodeMirror 인스턴스 접근
2. cm.scrollDOM으로 스크롤 요소 가져오기
3. scrollTop = scrollHeight - clientHeight로 설정

### 장점
- CodeMirror 공식 API라 가장 안정적
- 버전 변경에도 호환성 유지
- 정확히 의도된 스크롤 요소 접근

### 단점
- Obsidian이 editor.cm을 노출하는지 확인 필요
- CodeMirror 6 전용 (이전 버전 불가)

### 안정성: ★★★★★
공식 API라 가장 신뢰할 수 있음

### 간결성: ★★★★★
가장 직접적이고 간단함

---

## 방법 3: View의 contentEl에서 querySelector

### 원리
view.contentEl에서 CSS 선택자로 에디터 요소를 찾습니다.

### 로직 흐름
1. view.contentEl.querySelector('.cm-scroller') 실행
2. 찾은 요소의 scrollTop 설정

### 장점
- 한 줄로 요소 찾기 가능
- contentEl은 Obsidian이 보장하는 속성

### 단점
- 클래스명 '.cm-scroller'에 의존
- 요소를 못 찾으면 null 처리 필요
- 여러 에디터가 있으면 첫 번째만 선택됨

### 안정성: ★★★☆☆
클래스명 변경 시 문제 발생

### 간결성: ★★★★☆
간단하지만 null 체크 필요

---

## 방법 4: editor 객체에서 DOM 추출

### 원리
Obsidian의 editor 객체가 내부적으로 가진 DOM 참조를 활용합니다.

### 로직 흐름
1. editor.cm 또는 editor 내부 속성 확인
2. 적절한 DOM 요소 추출
3. 스크롤 설정

### 장점
- editor 객체에서 직접 접근
- view를 거치지 않아도 됨

### 단점
- editor의 내부 구조를 알아야 함
- 공식 문서화되지 않은 속성일 수 있음

### 안정성: ★★★☆☆
비공식 속성 의존 가능성

### 간결성: ★★★☆☆
editor의 구조를 이해해야 함

---

## 방법 5: 임시 요소 삽입 후 스크롤

### 원리
문서 끝에 임시 요소를 추가하고, 그 요소로 스크롤한 후 삭제합니다.

### 로직 흐름
1. 문서 맨 끝에 빈 줄 여러 개 추가
2. 마지막 줄로 커서 이동 (자동 스크롤)
3. 추가한 줄 삭제

### 장점
- DOM 직접 조작 불필요
- 에디터 API만 사용

### 단점
- 파일 내용을 임시로 변경
- Undo 히스토리 영향 가능
- 깜빡임 발생 가능

### 안정성: ★★☆☆☆
파일 수정으로 인한 부작용 가능

### 간결성: ★★☆☆☆
추가/삭제 로직 복잡

---

## 종합 비교표

| 방법 | 안정성 | 간결성 | 의존성 | 추천도 |
|------|--------|--------|--------|--------|
| 일반 DOM 접근 | ★★★☆☆ | ★★★☆☆ | DOM 구조 | ★★★☆☆ |
| **editor.cm.scrollDOM** | **★★★★★** | **★★★★★** | **CodeMirror 6** | **★★★★★** |
| querySelector | ★★★☆☆ | ★★★★☆ | 클래스명 | ★★★★☆ |
| editor 내부 속성 | ★★★☆☆ | ★★★☆☆ | 내부 구조 | ★★☆☆☆ |
| 임시 요소 삽입 | ★★☆☆☆ | ★★☆☆☆ | 없음 | ★☆☆☆☆ |

---

## 최종 추천

### 1순위: editor.cm.scrollDOM 사용
```
가장 안정적이고 간결함
CodeMirror 공식 API
Obsidian이 cm 접근 허용 시 베스트
```

**확인 필요 사항:**
- editor.cm이 존재하는지
- cm.scrollDOM에 접근 가능한지

**대체 방안:**
만약 접근 불가하면 2순위로

---

### 2순위: view.contentEl.querySelector('.cm-scroller')
```
비교적 간단하고 안정적
Obsidian이 보장하는 contentEl 사용
클래스명만 유지되면 작동
```

**확인 필요 사항:**
- '.cm-scroller' 클래스명 확인
- null 체크 필수

**대체 방안:**
클래스명이 다르면 개발자 도구로 실제 클래스 확인

---

### 3순위: 일반 DOM 탐색
```
확실하게 작동하지만 복잡
모든 경우의 폴백으로 사용
```

**사용 상황:**
- 위 방법들이 모두 실패할 때
- 특수한 에디터 구조일 때

---

## 실무 권장 전략

### 단계별 시도
1. editor.cm.scrollDOM 먼저 시도
2. 실패 시 querySelector('.cm-scroller')
3. 둘 다 실패 시 contentEl에서 DOM 탐색

### 방어적 코딩
각 방법마다 존재 여부 확인 후 실행
```
체크 → 실행 → 실패 시 다음 방법
```

### 에러 처리
스크롤 실패 시 조용히 넘어가기
(사용자는 커서 이동만으로도 어느 정도 만족)

---

## 구현 복잡도 비교

### 가장 간단한 코드
editor.cm.scrollDOM 방식
- 3-4줄이면 완성
- 조건문 최소

### 중간 복잡도
querySelector 방식
- null 체크 포함 5-6줄
- 클래스명 상수화 권장

### 복잡한 코드
일반 DOM 탐색
- 10줄 이상
- 여러 체크 필요

### 가장 복잡
임시 요소 방식
- 15줄 이상
- 타이밍 이슈 처리

---

## 결론

**단순함과 안정성을 모두 원한다면:**
editor.cm.scrollDOM 사용 (가능하다면)

**확실한 호환성을 원한다면:**
querySelector('.cm-scroller') 사용

**완벽한 폴백을 원한다면:**
여러 방법을 순차적으로 시도하는 하이브리드 접근
