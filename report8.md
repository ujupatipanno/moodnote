# 커서 위치 가시성 개선 방안

## 문제 상황
스크롤이 커서 위치까지는 이동하지만, 커서가 화면 맨 아래에 붙어서 보여서 가시성이 좋지 않음.

## 원하는 동작
커서가 있는 행이 화면 중앙이나 중앙보다 약간 위쪽에 표시되어야 함.

---

## 해결 방안

### 방안 0: 커서 이동 후 문서 끝으로 스크롤 (제안된 방안)
**로직:**
- 커서를 원하는 위치(오늘 섹션)로 이동
- 그다음 스크롤을 문서 맨 끝으로 이동

**의도:**
- 스크롤이 문서 끝으로 가면, 커서가 있는 위치가 화면 상단 쪽에 보이게 됨

**작동 분석:**
1. 오늘 섹션이 80번 줄에 있다고 가정
2. 커서를 80번 줄로 이동
3. 스크롤을 문서 끝(예: 150번 줄)으로 이동
4. 결과: 화면에는 80~150줄이 보이고, 커서는 80줄(화면 상단)에 위치

**실제 결과 예측:**
- **오늘 섹션이 문서 중간쯤에 있는 경우:**
  - 스크롤이 끝으로 가면 오늘 섹션은 화면 밖(위쪽)으로 사라짐
  - 커서만 위에 있고 화면엔 문서 끝부분만 보임
  - **문제 발생!**

- **오늘 섹션이 문서 끝 근처에 있는 경우:**
  - 커서와 문서 끝이 가까우므로
  - 스크롤을 끝으로 보내도 커서가 화면에 보임
  - **괜찮을 수 있음**

**장점:**
- 구현이 매우 간단
- 오늘 섹션이 문서 끝 부분에 있을 때 잘 작동

**단점:**
- **치명적 문제:** 오늘 섹션이 문서 중간에 있으면 커서가 화면 밖으로 벗어남
- 일기를 많이 쓸수록 오늘 섹션은 문서 끝에 가까워지지만, 초반에는 중간에 있음
- 예측 불가능한 동작

**개선안:**
- "커서 위치에서 일정량 더 아래로 스크롤" 하면 더 안전함
- 문서 끝이 아니라 "커서 + 10줄 아래" 같은 상대적 위치로

**결론:**
- **비추천**: 오늘 섹션 위치에 따라 결과가 너무 다름
- 대신 "커서 + 오프셋" 방식이 더 안정적

---

### 방안 1: 커서 위치를 화면 중앙에 배치
**로직:**
- 커서를 원하는 위치로 이동
- 그 위치가 화면 중앙에 오도록 스크롤 조정

**작동 방식:**
- CodeMirror나 Obsidian API에서 "이 줄을 화면 중앙에 보여줘" 같은 옵션 사용
- 보통 `scrollIntoView` 메서드에 중앙 정렬 옵션을 줌

**장점:**
- 가장 이상적인 가시성
- 위아래 맥락 모두 보임

**단점:**
- API 지원 여부 확인 필요

---

### 방안 2: 커서 아래에 빈 줄 임시 추가
**로직:**
- 커서를 원하는 위치로 이동
- 그 아래에 빈 줄 여러 개를 임시로 추가
- 스크롤이 조정됨
- 추가한 빈 줄을 다시 삭제

**작동 방식:**
1. 타겟 라인으로 커서 이동
2. 그 아래에 "\n\n\n\n\n" 같은 걸 추가
3. 스크롤이 내려가면서 원래 라인이 위로 올라옴
4. 추가한 줄 삭제

**장점:**
- 확실하게 작동
- 특별한 API 필요 없음

**단점:**
- 트릭에 가까움
- Undo 히스토리에 영향 줄 수 있음
- 깜빡임 가능성

---

### 방안 3: 스크롤 위치 직접 계산
**로직:**
- 현재 에디터의 높이를 구함
- 한 줄의 높이를 구함
- 커서 위치에서 (에디터 높이 / 2) 정도를 더한 만큼 스크롤

**작동 방식:**
- 에디터 총 높이 픽셀값 얻기
- 라인 하나의 픽셀 높이 얻기
- "커서를 중앙에 두려면 몇 픽셀 스크롤해야 하나" 계산
- 직접 스크롤 위치 설정

**장점:**
- 정밀한 제어 가능

**단점:**
- CodeMirror 내부 구조 의존
- 복잡한 계산
- 폰트 크기나 줄 간격 변경 시 영향 받음

---

### 방안 4: 커서 위치 + 오프셋 스크롤
**로직:**
- 커서를 원하는 위치로 이동
- 그 위치에서 추가로 몇 줄 더 아래로 스크롤 이동

**작동 방식:**
- 먼저 커서를 타겟 라인으로 이동 (자동 스크롤 발생)
- 그다음 현재 스크롤 위치를 가져와서
- "5줄 정도 더 내려줘" 같은 오프셋 추가

**장점:**
- 간단한 보정
- 기존 자동 스크롤 활용

**단점:**
- 문서 끝 부분에서는 더 내릴 수 없음
- 오프셋 값 조정 필요

---

### 방안 5: 가상의 더 아래 위치로 커서 이동 후 원위치
**로직:**
- 실제 타겟보다 몇 줄 아래로 커서를 먼저 보냄
- 스크롤이 조정됨
- 그다음 원래 타겟 위치로 커서를 다시 이동

**작동 방식:**
1. 타겟이 80번 줄이라면
2. 먼저 85번 줄로 커서 이동 (스크롤이 85줄 기준으로 조정)
3. 다시 80번 줄로 커서 이동 (스크롤은 유지되고 커서만 위로)

**장점:**
- 간단한 트릭
- 추가 API 불필요

**단점:**
- 문서 끝에서는 작동 안 함
- 커서가 두 번 움직이는 게 보일 수 있음

---

### 방안 6: CodeMirror scrollIntoView에 padding 옵션
**로직:**
- 커서를 화면에 보여줄 때 "위아래로 여백을 얼마나 둘지" 설정

**작동 방식:**
- CodeMirror의 scrollIntoView에 `{ y: "center" }` 같은 옵션 전달
- 또는 `{ yMargin: 200 }` 같은 픽셀 여백 지정

**장점:**
- 가장 깔끔한 방법
- API가 제공하는 정석 방식

**단점:**
- Obsidian의 editor 객체가 이 기능을 노출하는지 확인 필요

---

### 방안 7: 문서 끝에 임시 여백 추가 후 제거
**로직:**
- 문서 맨 끝에 빈 줄을 미리 많이 추가
- 커서 이동 (이제 스크롤 여유 생김)
- 나중에 빈 줄 삭제

**작동 방식:**
- 파일을 열고 오늘 섹션 찾기 전에
- 문서 끝에 "\n\n\n\n\n\n\n\n\n\n" 추가
- 커서 이동하면 충분히 스크롤 가능
- 모든 작업 끝나고 추가한 줄 삭제

**장점:**
- 문서 끝 문제 해결
- 스크롤 여유 확보

**단점:**
- 복잡함
- 타이밍 이슈
- 사용자가 깜빡임 느낄 수 있음

---

### 방안 8: 플랫폼별 분기 처리
**로직:**
- 데스크탑과 모바일을 다르게 처리
- 데스크탑에서만 추가 스크롤 조정

**작동 방식:**
```
if (데스크탑이면) {
    커서 이동 후 추가 스크롤 조정
} else {
    그냥 커서만 이동
}
```

**장점:**
- 각 환경에 최적화

**단점:**
- 코드 복잡도 증가
- 유지보수 어려움

---

## 추천 순서

### 1순위: 방안 6 시도
CodeMirror의 scrollIntoView나 관련 API에 중앙 정렬 옵션이 있는지 확인.
있다면 가장 깔끔한 해결책.

### 2순위: 방안 5 적용
실제 타겟보다 5~10줄 아래로 먼저 이동했다가 다시 타겟으로 돌아오기.
간단하고 효과적.

### 3순위: 방안 4 적용
커서 이동 후 스크롤 위치에 오프셋 추가.
비교적 안정적.

---

## 실험 필요
- Obsidian editor 객체가 어떤 스크롤 관련 메서드를 제공하는지 확인
- CodeMirror 6의 scrollIntoView 옵션을 Obsidian에서 사용 가능한지 테스트
- 각 방안의 실제 동작을 직접 테스트

## 가장 간단한 시작점
방안 5를 먼저 시도: 타겟보다 몇 줄 아래로 커서 이동 → 원위치
