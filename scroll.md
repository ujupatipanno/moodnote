# Obsidian에서 스크롤을 움직이는 다양한 방법

## 방법 1: 커서 이동으로 자동 스크롤
커서를 특정 위치로 옮기면 에디터가 자동으로 그 위치를 화면에 보여주려고 스크롤을 조정합니다. 가장 기본적이고 간단한 방법이지만, 커서가 화면 어디에 위치할지는 에디터가 알아서 결정합니다. 보통 커서가 화면 밖으로 벗어나지 않도록 최소한만 스크롤됩니다.

---

## 방법 2: 두 위치로 연속 커서 이동
먼저 원하는 위치보다 더 아래(또는 위)로 커서를 이동시킨 후, 다시 원래 원하는 위치로 돌아옵니다. 첫 이동에서 스크롤이 크게 움직이고, 두 번째 이동에서는 커서만 조정되어 스크롤 위치가 유지됩니다. 결과적으로 원하는 위치가 화면의 원하는 부분에 오도록 만들 수 있습니다.

---

## 방법 3: 문서 끝으로 스크롤 후 커서 유지
목표 위치로 커서를 이동한 후, 추가로 문서의 맨 끝으로 스크롤을 보냅니다. 이렇게 하면 원래 커서가 있던 위치가 화면 상단 쪽에 보이게 됩니다. 하지만 목표가 문서 중간에 있을 경우 커서가 화면 밖으로 사라질 수 있습니다.

---

## 방법 4: scrollIntoView 메서드 사용
CodeMirror나 Obsidian API가 제공하는 스크롤 메서드를 직접 호출합니다. 특정 위치를 화면 중앙, 상단, 하단 등 원하는 곳에 배치하도록 옵션을 줄 수 있습니다. 가장 정확하고 깔끔한 방법이지만, 해당 API가 Obsidian 플러그인에서 접근 가능한지 확인이 필요합니다.

---

## 방법 5: 픽셀 단위 직접 스크롤
에디터의 스크롤 위치를 픽셀 단위로 직접 설정합니다. 특정 줄이 화면 어디에 위치할지 계산해서 정확한 픽셀 값을 지정할 수 있습니다. 매우 정밀한 제어가 가능하지만, 줄 높이나 폰트 크기가 바뀌면 계산이 틀어질 수 있습니다.

---

## 방법 6: DOM 요소 직접 조작
CodeMirror의 내부 DOM 구조에 접근해서 스크롤 컨테이너를 직접 조작합니다. 가장 로우레벨 방식으로, 원하는 대로 제어할 수 있지만 Obsidian 버전이 바뀌면 깨질 위험이 있습니다. 일반적으로 권장되지 않는 방법입니다.

---

## 방법 7: 임시 콘텐츠 추가/삭제
스크롤할 공간을 만들기 위해 문서에 임시로 빈 줄을 추가합니다. 예를 들어 문서 끝에 빈 줄 10개를 추가하면 더 아래로 스크롤할 수 있게 됩니다. 원하는 스크롤 위치를 만든 후 추가했던 빈 줄을 삭제합니다. 트릭에 가깝지만 확실한 효과가 있습니다.

---

## 방법 8: 뷰포트 계산 활용
현재 화면에 보이는 영역(뷰포트)의 크기를 계산합니다. 목표 위치를 화면 중앙에 두려면 "목표 - (화면 높이 / 2)"만큼 스크롤하면 됩니다. 수학적으로 정확하지만, 에디터 UI 요소들을 고려해야 해서 계산이 복잡할 수 있습니다.

---

## 방법 9: 블록 단위 스크롤
페이지 위/아래 키를 누른 것처럼 한 화면씩 스크롤합니다. 현재 스크롤 위치에서 상대적으로 일정량을 더하거나 빼는 방식입니다. 정확한 위치 제어보다는 대략적인 이동에 적합합니다.

---

## 방법 10: 여백(Margin) 설정으로 스크롤
스크롤할 때 "위아래로 얼마만큼의 여백을 둘지" 설정합니다. 예를 들어 상단 여백을 200픽셀로 설정하면, 커서가 화면 최소 200픽셀 아래에 위치하도록 스크롤됩니다. CodeMirror가 이런 옵션을 지원한다면 가장 자연스러운 방법입니다.

---

## 방법 11: 애니메이션 스크롤
스크롤을 즉시 이동시키지 않고 부드럽게 애니메이션으로 이동시킵니다. 사용자 경험상 갑작스럽지 않아 좋지만, 구현이 복잡하고 타이밍 문제가 생길 수 있습니다. 또한 사용자가 애니메이션이 끝나기 전에 다른 작업을 하면 혼란스러울 수 있습니다.

---

## 방법 12: 포커스 후 렌더링 대기
에디터에 포커스를 준 후, 다음 프레임이 렌더링될 때까지 기다립니다. 그다음 커서를 이동하면 에디터가 완전히 준비된 상태여서 스크롤이 더 안정적으로 작동합니다. 비동기 처리가 필요하지만, 타이밍 문제를 많이 해결할 수 있습니다.

---

## 방법 13: 현재 스크롤 위치 읽고 조정
지금 스크롤이 어디 있는지 먼저 확인합니다. 그다음 "현재 위치에서 500픽셀 더 내려가기" 같은 상대적 조정을 합니다. 절대 위치를 계산하지 않아도 되어 간편하지만, 시작점이 예측 불가능하면 결과도 예측하기 어렵습니다.

---

## 방법 14: 특정 요소를 화면 중앙에
특정 줄이나 텍스트 블록을 정확히 화면 중앙에 배치하도록 합니다. 브라우저의 표준 메서드인 scrollIntoView에 중앙 정렬 옵션을 주는 방식입니다. 모든 경우에 일관되게 작동하지만, 문서 끝 부분에서는 중앙에 못 올 수 있습니다.

---

## 방법 15: 상황별 분기 처리
문서의 어느 부분에 있는지에 따라 다른 스크롤 전략을 사용합니다. 예를 들어 문서 시작 부분에서는 A 방법, 중간에서는 B 방법, 끝 부분에서는 C 방법을 씁니다. 가장 완벽한 사용자 경험을 만들 수 있지만, 코드가 복잡해지고 유지보수가 어렵습니다.

---

---

## 방법 16: 스크롤을 물리적 끝까지 밀기
문서의 마지막 줄로 이동하는 것이 아니라, 스크롤바를 실제로 끝까지 내립니다. 에디터의 스크롤 컨테이너에 접근해서 scrollTop을 최댓값(scrollHeight - clientHeight)으로 설정합니다. 이렇게 하면 문서 끝이 화면 맨 아래에 오고, 위쪽 내용이 화면 상단에 보입니다. 커서 위치와 무관하게 순수하게 스크롤만 제어할 수 있습니다.

---

## "문서 끝 도달" vs "화면을 끝까지 밀기"의 차이

### 문서 끝 도달 (커서 기반)
마지막 줄로 커서를 이동시키면, 에디터가 그 줄을 화면에 보여주려고 스크롤합니다. 하지만 에디터는 "최소한의 스크롤"만 하려고 하므로, 마지막 줄이 화면 어딘가에만 보이면 됩니다. 결과적으로 마지막 줄이 화면 하단이나 중간쯤에 위치할 수 있고, 스크롤이 끝까지 내려가지 않습니다.

### 화면을 끝까지 밀기 (스크롤 기반)
스크롤바 자체를 물리적으로 맨 아래까지 내립니다. 이렇게 하면 문서의 마지막 부분이 화면 하단에 딱 붙고, 더 이상 아래로 스크롤할 수 없는 상태가 됩니다. 커서가 어디 있든 상관없이 스크롤 위치 자체를 제어하는 방식입니다.

### 실제 차이 예시
100줄짜리 문서에서 80줄에 커서를 두고:
- **문서 끝 도달:** 100줄로 커서 이동 → 100줄이 화면 어딘가에 보임 → 스크롤은 95줄쯤 위치할 수 있음
- **화면 끝까지 밀기:** 스크롤을 최댓값으로 설정 → 100줄이 화면 맨 아래 → 80줄이 화면 상단 쪽에 보임

---

## 방법 17: 목표 위치 + 스크롤 최대화 조합
목표 위치로 커서를 먼저 이동한 후, 스크롤을 물리적 끝까지 밉니다. 이렇게 하면 목표 위치가 화면 상단 쪽에 나타나면서, 그 아래 모든 내용이 보입니다. 두 가지 동작을 조합해서 커서 위치와 가시성을 모두 확보하는 방법입니다.

---

## 실제 구현 시 접근 방법

### DOM 접근으로 스크롤 최대화
CodeMirror 에디터의 스크롤 컨테이너 요소를 찾습니다. 그 요소의 scrollTop 속성을 scrollHeight에서 clientHeight를 뺀 값으로 설정합니다. 이것이 스크롤을 물리적으로 끝까지 미는 정석 방법입니다.

### CodeMirror 6 API 활용
CodeMirror 6는 scrollDOM이라는 속성으로 스크롤 컨테이너에 접근할 수 있습니다. Obsidian에서 editor.cm을 통해 CodeMirror 인스턴스에 접근 가능하다면, 이 방법을 쓸 수 있습니다. 더 안정적이고 버전 변경에 강합니다.

### View 요소 통해 접근
Obsidian의 view 객체에서 에디터 DOM 요소를 탐색합니다. contentEl을 통해 에디터 컨테이너를 찾고, 그 안에서 스크롤 가능한 요소를 찾습니다. 찾은 요소의 스크롤을 최댓값으로 설정합니다.

---

## 추천 조합

### 일반적인 경우
포커스를 먼저 주고, 렌더링을 한 프레임 대기한 후, scrollIntoView로 중앙 정렬합니다. 이 조합이 가장 안정적이고 예측 가능합니다.

### API가 제한적인 경우  
포커스 후 두 위치로 연속 커서 이동 방법을 사용합니다. 간단하면서도 대부분의 경우 효과적입니다.

### 완벽을 추구하는 경우
문서 위치에 따라 분기 처리하되, 필요시 임시 콘텐츠 추가 방법을 섞습니다. 복잡하지만 모든 엣지 케이스를 커버할 수 있습니다.

### 목표 위치를 화면 상단에 두고 싶은 경우
목표 위치로 커서를 이동한 후, 스크롤을 물리적 끝까지 밉니다. 간단하면서도 목표가 항상 화면 상단 영역에 보이게 만듭니다.
